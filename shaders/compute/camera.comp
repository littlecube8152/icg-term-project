#include "compute/constants.comp"
#include "compute/globals.comp"
#include "compute/vecutil.comp"
#include "compute/interval.comp"
#include "compute/ray.comp"
#include "compute/hit_record.comp"
#include "compute/objects/objects.comp"


void Camera_initViewport() {
    camera.aspect_ratio = float(config.image_width) / float(config.image_height);
    camera.pixel_samples_delta = 1.0f / float(config.sqrt_samples_per_pixel);

    vec3 uz = normalize(config.lookfrom - config.lookat);
    vec3 uy = normalize(perp_unit(config.lookup, uz));
    vec3 ux = cross(uy, uz);

    camera.pixel_samples_scale = 1.0f / float(config.sqrt_samples_per_pixel * config.sqrt_samples_per_pixel);
    float tan_vfov2 = tan(config.vfov / 2 / 180 * kPi);
    camera.viewport_lower_left = config.lookfrom + -tan_vfov2 * camera.aspect_ratio * ux + -tan_vfov2 * uy - uz;
    camera.viewport_dx = tan_vfov2 * 2 * camera.aspect_ratio / float(config.image_width) * ux;
    camera.viewport_dy = tan_vfov2 * 2 / float(config.image_height) * uy;
}

Ray Camera_getRayToPixel(vec2 pixel_coord) {
    vec3 pixel_position = vec3(camera.viewport_lower_left + camera.viewport_dx * pixel_coord.x + camera.viewport_dy * pixel_coord.y);
    return Ray(
        vec4(config.lookfrom, 0.0),
        normalize(pixel_position - config.lookfrom),
        Interval_positive
    );
}

bool Camera_hitAllObjects(Ray ray, out HitRecord record) {
    // TODO: relativistic transformation on ray
    HitRecord hit_result;
    bool hit_any = false;
    for (int i = 0; i < n_objects; i++) {
        if (Object_hit(objects[i], ray, hit_result)) {
            hit_any = true;
            ray.interval.max = hit_result.alpha;
            record = hit_result;
        }
    }
    return hit_any;
}

vec4 Camera_getRayColor(Ray ray) {
    vec4 accum_attenuation = vec4(1, 1, 1, 1);
    HitRecord record;
    for (int depth = 0; depth < config.max_recursion_depth; depth++) {
        if (!Camera_hitAllObjects(ray, record)) {
            float dotval = dot(ray.direction, vec3(0, 1, 0));
            float ratio = (dotval + 1) / 2.0f;
            vec4 sky_color = (1.0f - ratio) * vec4(1, 1, 1, 1) + ratio * vec4(0.5, 0.7, 1.0, 1.0);
            return accum_attenuation * sky_color;
        }
        if (!record.has_scattered) {
            return vec4(0, 0, 0, 1);
        }
        accum_attenuation *= record.attenuation;
        ray = record.scattered_ray;
    }
    return vec4(0, 0, 0, 1);
}

vec4 Camera_getPixelColor(ivec2 pixel_coord) {
    vec4 pixel_color = vec4(0, 0, 0, 0);
    for (int dx = 0; dx < config.sqrt_samples_per_pixel; dx++) {
        for (int dy = 0; dy < config.sqrt_samples_per_pixel; dy++) {
            Ray sampled_ray = Camera_getRayToPixel(
                vec2(pixel_coord) + camera.pixel_samples_delta * vec2(dx, dy)
            );
            pixel_color += Camera_getRayColor(sampled_ray);
        }
    }
    pixel_color *= camera.pixel_samples_scale;
    pixel_color = sqrt(pixel_color);
    return pixel_color;
}
