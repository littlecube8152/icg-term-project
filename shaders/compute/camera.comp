#include "compute/constants.comp"
#include "compute/uniforms.comp"
#include "compute/vecutil.comp"
#include "compute/interval.comp"
#include "compute/ray.comp"
#include "compute/hit_record.comp"
#include "compute/objects/objects.comp"
#include "compute/color.comp"


Ray Camera_getRayToPixel(vec2 pixel_coord, float time) {
    vec3 pixel_position = (camera.viewport_lower_left + camera.viewport_dx * pixel_coord.x + camera.viewport_dy * pixel_coord.y).xyz;
    return Ray_new(vec4(camera.lookfrom.xyz, time), 
                   normalize(pixel_position - camera.lookfrom.xyz), 
                   camera.iframe.xyz);
}

Ray Camera_getRayToPixel(vec2 pixel_coord) {
    return Camera_getRayToPixel(pixel_coord, 0.0f);
}

bool Camera_hitAllObjects(Ray ray, out HitRecord record) {
    HitRecord hit_result;
    bool hit_any = false;
    for (int i = 0; i < n_objects; i++) {
        if (Object_hit(i, ray, hit_result)) {
            hit_any = true;
            ray.interval.max = hit_result.alpha;
            record = hit_result;
        }
    }
    return hit_any;
}


vec4 Camera_getRayColor(Ray ray) {
    vec4 accum_attenuation = vec4(1, 1, 1, 1);
    vec4 object_space_color = vec4(0, 0, 0, 1);
    // record the first hit for doppler effect of light
    bool first_hit = false;
    HitRecord first_record;
    
    HitRecord record;
    for (int depth = 0; depth < camera.max_recursion_depth; depth++) {
        if (!Camera_hitAllObjects(ray, record)) {
            // sky box
            float dotval = dot(ray.direction, vec3(0, 1, 0));
            float ratio = (dotval + 1) / 2.0f;
            vec4 sky_color = (1.0f - ratio) * vec4(1, 1, 1, 1) + ratio * vec4(0.2, 0.2, 1.0, 1.0);
            object_space_color = accum_attenuation * sky_color;
            break;
        }
        if (!first_hit) {
            first_hit = true;
            first_record = record;
        }
        if (!record.has_scattered) {
            // light absorbed by the object
            object_space_color = vec4(0, 0, 0, 1);
            break;
        }
        accum_attenuation *= record.attenuation;
        ray = record.scattered_ray;
    }

    // doppler effect of light
    // if (first_hit) {
    //     vec3 velocity = IFrame_transformVelocityFrom(camera.iframe.xyz, world_iframe.xyz, vec3(0, 0, 0));
    //     vec3 line_of_sight = IFrame_transformCoordinateFrom(camera.iframe.xyz, world_iframe.xyz, first_record.ray.origin.w / kSpeedOfLight, first_record.ray.origin.xyz).yzw - camera.lookfrom.xyz;
    //     float cosine = dot(default_normalize(velocity, velocity), normalize(line_of_sight));
    //     float beta = IFrame_getBetaScalar(camera.iframe.xyz, world_iframe.xyz);
    //     float scale = sqrt((1.0f - beta * cosine) / (1.0f + beta * cosine));
    //     object_space_color = vec4(Color_lightWavelengthShift(object_space_color.rgb, scale), object_space_color.a);
    // }
    return object_space_color;
}

vec4 Camera_getPixelColor(ivec2 pixel_coord, float time) {
    vec4 pixel_color = vec4(0, 0, 0, 0);
    for (int dx = 0; dx < camera.sqrt_samples_per_pixel; dx++) {
        for (int dy = 0; dy < camera.sqrt_samples_per_pixel; dy++) {
            Ray sampled_ray = Camera_getRayToPixel(
                vec2(pixel_coord) + camera.pixel_samples_delta * vec2(dx, dy),
                time
            );
            pixel_color += Camera_getRayColor(sampled_ray);
        }
    }
    pixel_color *= camera.pixel_samples_scale;
    pixel_color = Color_gammaCorrection(pixel_color);
    return pixel_color;
}

vec4 Camera_getPixelColor(ivec2 pixel_coord) {
    return Camera_getPixelColor(pixel_coord, 0.0f);
}