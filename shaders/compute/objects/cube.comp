#include "compute/defs.comp"
#include "compute/objects/object_types.h"
#include "compute/ray.comp"
#include "compute/hit_record.comp"
#include "compute/interval.comp"
#include "compute/vecutil.comp"
#include "compute/constants.comp"
#include "compute/materials/materials.comp"


Object Cube_new(vec3 center, float side_length, int material_id) {
    Object object;
    object.object_type = OBJECT_TYPE_CUBE;
    object.cube = Cube(vec4(center, 0), side_length, material_id);
    return object;
}

bool Cube_testHitSurface(inout Ray ray, inout HitRecord record, vec3 surface_corner, vec3 vec_u, vec3 vec_v) {
    vec3 normal = normalize(cross(vec_u, vec_v));
    float surface_level = dot(surface_corner, normal);
    float origin_level = dot(ray.origin.xyz, normal);
    float alpha_level = dot(ray.direction, normal);

    if (abs(alpha_level) < kEpsilon)
        return false;
    float alpha = (surface_level - origin_level) / alpha_level;
    if (!Interval_surrounds(ray.interval, alpha))
        return false;
    vec3 hit_point = Ray_at(ray, alpha).xyz;
    vec3 surface_hit_vector = hit_point - surface_corner;
    if (dot(cross(vec_u, surface_hit_vector), normal) >= 0 &&
        dot(cross(vec_v, surface_hit_vector), normal) <= 0 &&
        dot(cross(vec_u, surface_hit_vector - vec_v), normal) <= 0 &&
        dot(cross(vec_v, surface_hit_vector - vec_u), normal) >= 0) {
        ray.interval.max = alpha;
        record.alpha = alpha;
        record.coord = hit_point;
        HitRecord_setFaceNormal(record, ray, normal);
        return true;
    }
    return false;
}

bool Cube_hit(Cube cube, Ray ray, out HitRecord record) {
    vec3 corner_1 = cube.center.xyz - vec3(cube.side_length / 2);
    vec3 corner_2 = cube.center.xyz + vec3(cube.side_length / 2);
    vec3 x_axis = vec3(cube.side_length, 0, 0);
    vec3 y_axis = vec3(0, cube.side_length, 0);
    vec3 z_axis = vec3(0, 0, cube.side_length);
    bool hit = false;
    hit = Cube_testHitSurface(ray, record, corner_1,  x_axis,  z_axis) || hit;
    hit = Cube_testHitSurface(ray, record, corner_1,  z_axis,  y_axis) || hit;
    hit = Cube_testHitSurface(ray, record, corner_1,  y_axis,  x_axis) || hit;
    hit = Cube_testHitSurface(ray, record, corner_2, -x_axis, -z_axis) || hit;
    hit = Cube_testHitSurface(ray, record, corner_2, -z_axis, -y_axis) || hit;
    hit = Cube_testHitSurface(ray, record, corner_2, -y_axis, -x_axis) || hit;

    record.has_scattered = Material_scatter(cube.material_id, ray, record);

    return hit;
}
