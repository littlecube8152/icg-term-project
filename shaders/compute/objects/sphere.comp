#include "compute/defs.comp"
#include "compute/objects/object_types.h"
#include "compute/ray.comp"
#include "compute/hit_record.comp"
#include "compute/interval.comp"
#include "compute/vecutil.comp"
#include "compute/materials/materials.comp"


Object Sphere_new(vec3 center, float radius, int material_id, vec4 frame) {
    vec4 actual_center = IFrame_transformCoordinateFrom(frame.xyz, vec3(0.0f, 0.0f, 0.0f), 0.0f, center);

    Object object;
    object.object_type = OBJECT_TYPE_SPHERE;
    object.iframe = frame;
    object.sphere = Sphere(vec4(actual_center.xyz, 0), radius, material_id);
    return object;
}

Object Sphere_new(vec3 center, float radius, int material_id) {
    return Sphere_new(center, radius, material_id, vec4(0.0f, 0.0f, 0.0f, 0.0f));
}

bool Sphere_hit(Object object, Ray ray, out HitRecord record) {
    Sphere sphere = object.sphere;
    Ray object_space_ray = ray;
    Ray_transformFrame(object_space_ray, object.iframe.xyz);

    vec3 origin_to_center = sphere.center.xyz - object_space_ray.origin.xyz;
    vec3 proj = proj_unit(origin_to_center, object_space_ray.direction);
    vec3 closest = origin_to_center - proj;

    if (dot(closest, closest) > sphere.radius * sphere.radius)
        return false;
    
    float alpha = dot(proj, object_space_ray.direction);
    float d_alpha = sqrt(sphere.radius * sphere.radius - dot(closest, closest));

    float hit;
    if (Interval_surrounds(object_space_ray.interval, alpha - d_alpha))
        hit = alpha - d_alpha;
    else if (Interval_surrounds(object_space_ray.interval, alpha + d_alpha))
        hit = alpha + d_alpha;
    else
        return false;
    
    vec4 coord = Ray_at(object_space_ray, hit);
    record.alpha = hit;
    record.ray = Ray_new(coord, object_space_ray.direction, object_space_ray.iframe);
    HitRecord_setFaceNormal(record, (coord.xyz - sphere.center.xyz) / sphere.radius);
    record.has_scattered = Material_scatter(sphere.material_id, record);

    return true;
}
